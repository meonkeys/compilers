%option warn nodefault
%option noinput nounput noyywrap yylineno
/* %option debug */

%top{
/* For fileno(3). See feature_test_macros(7) manpage. */
#define _GNU_SOURCE
}

%{
/* System headers */
#include <assert.h>
#include <string.h> /* for memcmp() */

/* Custom headers */
#include <util.h>

static int num_tokens = 0;
static long num_chars = 0;
static List *comments = NULL;
static CommentPos *latest_comment_positions = NULL;
static ListItem *latest_comment = NULL;
struct hashtable *ht = NULL;

static void start_comment ();
static void end_comment ();
static void destroy_data (void *data);
static void handle_id (char *id);

/*
 * from
 * http://flex.sf.net/manual/How-do-I-track-the-byte-offset-for-lseek_0028_0029_003f.html
 */
#define YY_USER_ACTION num_chars += yyleng;
%}

/* reserved words */
RESERVED        return|typedef|if|else|int|float|for|struct|union|void|while
ID              [a-z][a-z0-9_]*
DIGIT           [0-9]
INT             {DIGIT}+
FLOAT           \.{DIGIT}+|{DIGIT}+\.|{DIGIT}+\.{DIGIT}+
STRING          \"[^"]*\"
ARITHOP         "+"|"-"|"*"|"/"
RELOP           "<"|">"|">="|"<="|"!="|"=="
LOGOP           "||"|"&&"|"!"
ASSIGNOP        "="
WHITESPACE      [ \t]+
SEPARATOR       "{"|"}"|"["|"]"|"("|")"|";"|","|"."
/* we still need to define string literals */

%x comment

%%

{RESERVED}      num_tokens++;
{ID}            {num_tokens++; handle_id(yytext);}
{INT}           num_tokens++;
{FLOAT}         num_tokens++;
{STRING}        num_tokens++;
{ARITHOP}       num_tokens++;
{RELOP}         num_tokens++;
{LOGOP}         num_tokens++;
{SEPARATOR}     num_tokens++;
{ASSIGNOP}      num_tokens++;

"/*"                    { BEGIN(comment); start_comment(); }
<comment>[^*\n]*        /* eat anything that's not a '*' */
<comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
<comment>\n             /* blank lines in comments are ok */
<comment>"*"+"/"        {
                                end_comment();
                                num_tokens++;
                                BEGIN(INITIAL);
                        }


{WHITESPACE}    {}
\n              {}
 .              { printf("Unrecognized character: %s on line: %d\n",
                         yytext, yylineno); }

%%

#define MIN_HT_SIZE 16

int main (int argc, char *argv[])
{
    comments = init_list ();
    assert (NULL != comments);
    ht = create_hashtable (MIN_HT_SIZE, ELFHash, equalkeys);
    assert (NULL != ht);

    yylex ();
    printf ("There are %d tokens /* comments are counted as tokens */\n",
            num_tokens);
    printf ("There are %d lines\n", yylineno);
    printf ("There are %ld comments:\n", comments->size);

    display_comments (comments, yyin);
    printf ("\n");

    /* print out the frequency of identifiers here */
    printf ("Frequency of identifiers:\n");
    display_hashtable (ht);

    destroy_list (comments, destroy_data);
    hashtable_destroy (ht, 1);

    /*
     * Not precisely as indicated by the manual, but seems to be the right
     * thing to do based on the C code generated by flex.
     */
    yylex_destroy ();

    return EXIT_SUCCESS;
}

/**
 * Record start of current comment within input stream (yyin). Note that the
 * scanner will already have read past the / and the *, so we have to account
 * for the difference.
 */
static void start_comment ()
{
    latest_comment_positions = malloc (sizeof (CommentPos));
    assert (NULL != latest_comment_positions);
    latest_comment_positions->start = num_chars - 2;
}

/*
 * End of comment is exactly num_chars when this function is called. This
 * includes the * and the /.
 */
static void end_comment ()
{
    latest_comment_positions->end = num_chars;
    latest_comment = init_item (latest_comment_positions);
    assert (NULL != latest_comment);
    append (comments, latest_comment);
}

static void destroy_data (void *data)
{
    free (data);
}

static void handle_id (char *id)
{
    HashKey *k = NULL;
    HashValue *found = NULL;
    HashValue *v = NULL;

    k = malloc(sizeof(HashKey));
    assert(NULL != k);
    v = malloc(sizeof(HashValue));
    assert(NULL != v);

    /* search table
     * if exists -> increment count
     * if not    -> add with a count of 1
     */
    k->key = ELFHash (id);
    if (NULL == (found = hashtable_search (ht, k)))
    {
        /* Not found */
        v->count = 1;
        v->id = strdup (id);
        assert (-1 == hashtable_insert (ht, k, v));
    }
    else
    {
        /* Found */
        v->count = found->count + 1;
        v->id = found->id;
        assert (-1 == hashtable_change (ht, k, v));
    }
}

