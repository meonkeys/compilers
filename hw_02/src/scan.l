%option warn nodefault
%option noinput nounput noyywrap yylineno
/* %option debug */

%top{
/* For fileno(3). See feature_test_macros(7) manpage. */
#define _GNU_SOURCE
}

%{
#include <assert.h>
#include "hashtable.h"
#include "hashtable_itr.h"
#include "hashtable_utility.h"
#include <list.h>
#include <string.h> /* for memcmp() */

/******************************************************************/

static unsigned int ELFHash(void* val)
{
   char* str = (char*)val;
   unsigned int hash = 0;
   unsigned int x    = 0;
   unsigned int i    = 0;
   unsigned int len  = strlen(str);

   for(i = 0; i < len; str++, i++)
   {
      hash = (hash << 4) + (*str);
      if((x = hash & 0xF0000000L) != 0)
      {
         hash ^= (x >> 24);
      }
      hash &= ~x;
   }

   return hash;
}

static int equalkeys(void *k1, void *k2)
{
    return (0 == memcmp(k1,k2,sizeof(HashKey)));
}

int valcomp(const void* hv1, const void* hv2){
	HashValue* val1 = (HashValue*)hv1;
	HashValue* val2 = (HashValue*)hv2;

	int result = strcmp(val1->id, val2->id);
	if(result == 0){
		return val1->count - val2->count;
	}
	return result;
}

/******************************************************************/

typedef struct comment_pos_t { long start; long end; } CommentPos;
void destroy_data(void *data) { free(data); }

int num_tokens = 0;
long num_chars = 0;
List *comments = NULL;
CommentPos *latest_comment_positions = NULL;
ListItem *latest_comment = NULL;

void start_comment();
void end_comment();
void display_comments();
void handle_id(char* id);
void display_hashtable(struct hashtable* ht);

HashKey *k = NULL;
HashValue *v = NULL;
HashValue *found = NULL;
struct hashtable* ht = NULL;
struct hashtable_itr* itr = NULL;

/*
 * from
 * http://flex.sf.net/manual/How-do-I-track-the-byte-offset-for-lseek_0028_0029_003f.html
 */
#define YY_USER_ACTION num_chars += yyleng;
%}

/* reserved words */
RESERVED        return|typedef|if|else|int|float|for|struct|union|void|while
ID              [a-z][a-z0-9_]*
DIGIT           [0-9]
INT             {DIGIT}+
FLOAT           \.{DIGIT}+|{DIGIT}+\.|{DIGIT}+\.{DIGIT}+
STRING          \"[^"]*\"
ARITHOP         "+"|"-"|"*"|"/"
RELOP           "<"|">"|">="|"<="|"!="|"=="
LOGOP           "||"|"&&"|"!"
ASSIGNOP        "="
WHITESPACE      [ \t]+
SEPARATOR       "{"|"}"|"["|"]"|"("|")"|";"|","|"."
/* we still need to define string literals */

%x comment

%%

{RESERVED}      num_tokens++;
{ID}            {num_tokens++; handle_id(yytext);}
{INT}           num_tokens++;
{FLOAT}         num_tokens++;
{STRING}        num_tokens++;
{ARITHOP}       num_tokens++;
{RELOP}         num_tokens++;
{LOGOP}         num_tokens++;
{SEPARATOR}     num_tokens++;
{ASSIGNOP}      num_tokens++;

"/*"                    { BEGIN(comment); start_comment(); }
<comment>[^*\n]*        /* eat anything that's not a '*' */
<comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
<comment>\n             /* blank lines in comments are ok */
<comment>"*"+"/"        {
                                end_comment();
                                num_tokens++;
                                BEGIN(INITIAL);
                        }


{WHITESPACE}    {}
\n              {}
 .              { printf("Unrecognized character: %s on line: %d\n",
                         yytext, yylineno); }

%%

int main (int argc, char *argv[])
{
    comments = init_list ();
	ht = create_hashtable(16, ELFHash, equalkeys);
	assert(NULL != ht);
	k = (HashKey*)malloc(sizeof(HashKey));
	v = (HashValue*)malloc(sizeof(HashValue));

    yylex ();
    printf ("There are %d tokens /* comments are counted as tokens */\n",
            num_tokens);
    printf ("There are %d lines\n", yylineno);
    printf ("There are %ld comments:\n", comments->size);

    display_comments();
    printf ("\n");

    /* print out the frequency of identifiers here */
    printf("Frequency of identifiers:\n");
	display_hashtable(ht);

    destroy_list (comments, destroy_data);
	hashtable_destroy(ht, 1);

    /*
     * Not precisely as indicated by the manual, but seems to be the right
     * thing to do based on the C code generated by flex.
     */
    yylex_destroy();

    return EXIT_SUCCESS;
}

/**
 * Record start of current comment within input stream (yyin). Note that the
 * scanner will already have read past the / and the *, so we have to account
 * for the difference.
 */
void start_comment ()
{
    latest_comment_positions = malloc (sizeof (CommentPos));
    assert(NULL != latest_comment_positions);
	latest_comment_positions->start = num_chars - 2;
}

/*
 * End of comment is exactly num_chars when this function is called. This
 * includes the * and the /.
 */
void end_comment ()
{
    latest_comment_positions->end = num_chars;
	latest_comment = init_item (latest_comment_positions);
	assert(NULL != latest_comment);
    append (comments, latest_comment);
}

void display_comments ()
{
    while (has_next (comments))
    {
        ListItem *next = next_item (comments);
        CommentPos *comment_pos = (CommentPos *) next->data;
        long left = comment_pos->end - comment_pos->start;
        int current = EOF;
        assert (0 == fseek (yyin, comment_pos->start, SEEK_SET));
        do
        {
            current = getc (yyin);
            assert (EOF != current);
            assert (EOF != putchar (current));
            left -= 1;
        }
        while (left > 0);
        assert (EOF != putchar ('\n'));
    }
}

void handle_id(char* id){
	/* search table
     * if exists -> increment count 
     * if not    -> add with a count of 1
     */
	k->key = ELFHash(id);
	v->id = strdup(id);
	if(NULL == (found = hashtable_search(ht, k))){
		/* Not found */
		v->count = 1;
		hashtable_insert(ht, k, v);
	}
	else{
		/* Found */
		v->count = found->count + 1;
		hashtable_change(ht, k, v);
	}
	k = (HashKey*)malloc(sizeof(HashKey));
	v = (HashValue*)malloc(sizeof(HashValue));
}

void display_hashtable(struct hashtable* ht){
	unsigned int size = hashtable_count(ht);
	
	HashValue* values = malloc(size * sizeof(HashValue));

	int i = 0;
	if(size > 0)
    {
        itr = hashtable_iterator(ht);
        do {
            v = hashtable_iterator_value(itr);

			values[i].id = v->id;
			values[i].count = v->count;
			i++;
        } while (hashtable_iterator_advance(itr));
    }
    free(itr);

	 qsort(values, size, sizeof(HashValue), valcomp);

	for(i = 0; i < size; i++){
		printf("%s %d\n", values[i].id, values[i].count);
	}

	free(values);
}

/*
 * Add reserved words to the hashtable eventually
 */

